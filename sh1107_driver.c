#include "sh1107_driver.h"
#include <util/delay.h> // Include for _delay_ms
#include <avr/io.h>     // Include for uint8_t, etc.

#define OLED_ADDR 0x3C

// ===== I2C functions =====
static void i2c_start(void) {
    TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
    while (!(TWCR & (1<<TWINT)));
}

static void i2c_stop(void) {
    TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
}

static void i2c_write(uint8_t data) {
    TWDR = data;
    TWCR = (1<<TWINT)|(1<<TWEN);
    while (!(TWCR & (1<<TWINT)));
}

void i2c_init(void) {
    TWSR = 0;
    TWBR = 32; // ~100kHz @ F_CPU=8MHz (adjust TWBR based on your F_CPU)
}

// ===== OLED low-level =====
static void oled_cmd(uint8_t cmd) {
    i2c_start();
    i2c_write((OLED_ADDR<<1) | 0);
    i2c_write(0x00); // Command mode
    i2c_write(cmd);
    i2c_stop();
}

static void oled_data(uint8_t data) {
    i2c_start();
    i2c_write((OLED_ADDR<<1) | 0);
    i2c_write(0x40); // Data mode
    i2c_write(data);
    i2c_stop();
}

// ===== 5x7 font table =====
const uint8_t font5x7[][5] = {
  {0x00,0x00,0x00,0x00,0x00}, // ' ' (ASCII 32)
  {0x00,0x00,0x5F,0x00,0x00}, // '!'
  {0x00,0x07,0x00,0x07,0x00}, // '"'
  {0x14,0x7F,0x14,0x7F,0x14}, // '#'
  {0x24,0x2A,0x7F,0x2A,0x12}, // '$'
  {0x23,0x13,0x08,0x64,0x62}, // '%'
  {0x36,0x49,0x55,0x22,0x50}, // '&'
  {0x00,0x05,0x03,0x00,0x00}, // '''
  {0x00,0x1C,0x22,0x41,0x00}, // '('
  {0x00,0x41,0x22,0x1C,0x00}, // ')'
  {0x14,0x08,0x3E,0x08,0x14}, // '*'
  {0x08,0x08,0x3E,0x08,0x08}, // '+'
  {0x00,0x50,0x30,0x00,0x00}, // ','
  {0x08,0x08,0x08,0x08,0x08}, // '-'
  {0x00,0x60,0x60,0x00,0x00}, // '.'
  {0x20,0x10,0x08,0x04,0x02}, // '/'
  {0x3E,0x51,0x49,0x45,0x3E}, // '0'
  {0x00,0x42,0x7F,0x40,0x00}, // '1'
  {0x42,0x61,0x51,0x49,0x46}, // '2'
  {0x21,0x41,0x45,0x4B,0x31}, // '3'
  {0x18,0x14,0x12,0x7F,0x10}, // '4'
  {0x27,0x45,0x45,0x45,0x39}, // '5'
  {0x3C,0x4A,0x49,0x49,0x30}, // '6'
  {0x01,0x71,0x09,0x05,0x03}, // '7'
  {0x36,0x49,0x49,0x49,0x36}, // '8'
  {0x06,0x49,0x49,0x29,0x1E}, // '9'
  {0x00,0x36,0x36,0x00,0x00}, // ':'
  {0x00,0x56,0x36,0x00,0x00}, // ';'
  {0x08,0x14,0x22,0x41,0x00}, // '<'
  {0x14,0x14,0x14,0x14,0x14}, // '='
  {0x00,0x41,0x22,0x14,0x08}, // '>'
  {0x02,0x01,0x51,0x09,0x06}, // '?'
  {0x32,0x49,0x79,0x41,0x3E}, // '@'
  {0x7E,0x11,0x11,0x11,0x7E}, // 'A'
  {0x7F,0x49,0x49,0x49,0x36}, // 'B'
  {0x3E,0x41,0x41,0x41,0x22}, // 'C'
  {0x7F,0x41,0x41,0x22,0x1C}, // 'D'
  {0x7F,0x49,0x49,0x49,0x41}, // 'E'
  {0x7F,0x09,0x09,0x09,0x01}, // 'F'
  {0x3E,0x41,0x49,0x49,0x7A}, // 'G'
  {0x7F,0x08,0x08,0x08,0x7F}, // 'H'
  {0x00,0x41,0x7F,0x41,0x00}, // 'I'
  {0x20,0x40,0x41,0x3F,0x01}, // 'J'
  {0x7F,0x08,0x14,0x22,0x41}, // 'K'
  {0x7F,0x40,0x40,0x40,0x40}, // 'L'
  {0x7F,0x02,0x0C,0x02,0x7F}, // 'M'
  {0x7F,0x04,0x08,0x10,0x7F}, // 'N'
  {0x3E,0x41,0x41,0x41,0x3E}, // 'O'
  {0x7F,0x09,0x09,0x09,0x06}, // 'P'
  {0x3E,0x41,0x51,0x21,0x5E}, // 'Q'
  {0x7F,0x09,0x19,0x29,0x46}, // 'R'
  {0x46,0x49,0x49,0x49,0x31}, // 'S'
  {0x01,0x01,0x7F,0x01,0x01}, // 'T'
  {0x3F,0x40,0x40,0x40,0x3F}, // 'U'
  {0x1F,0x20,0x40,0x20,0x1F}, // 'V'
  {0x7F,0x20,0x18,0x20,0x7F}, // 'W'
  {0x63,0x14,0x08,0x14,0x63}, // 'X'
  {0x07,0x08,0x70,0x08,0x07}, // 'Y'
  {0x61,0x51,0x49,0x45,0x43}, // 'Z'
  {0x00,0x7F,0x41,0x41,0x00}, // '['
  {0x02,0x04,0x08,0x10,0x20}, // '\'
  {0x00,0x41,0x41,0x7F,0x00}, // ']'
  {0x04,0x02,0x01,0x02,0x04}, // '^'
  {0x40,0x40,0x40,0x40,0x40}, // '_'
  {0x00,0x01,0x02,0x04,0x00}, // '`'
  {0x20,0x54,0x54,0x54,0x78}, // 'a'
  {0x7F,0x48,0x44,0x44,0x38}, // 'b'
  {0x38,0x44,0x44,0x44,0x20}, // 'c'
  {0x38,0x44,0x44,0x48,0x7F}, // 'd'
  {0x38,0x54,0x54,0x54,0x18}, // 'e'
  {0x08,0x7E,0x09,0x01,0x02}, // 'f'
  {0x0C,0x52,0x52,0x52,0x3E}, // 'g'
  {0x7F,0x08,0x04,0x04,0x78}, // 'h'
  {0x00,0x44,0x7D,0x40,0x00}, // 'i'
  {0x20,0x40,0x44,0x3D,0x00}, // 'j'
  {0x7F,0x10,0x28,0x44,0x00}, // 'k'
  {0x00,0x41,0x7F,0x40,0x00}, // 'l'
  {0x7C,0x04,0x18,0x04,0x78}, // 'm'
  {0x7C,0x08,0x04,0x04,0x78}, // 'n'
  {0x38,0x44,0x44,0x44,0x38}, // 'o'
  {0x7C,0x14,0x14,0x14,0x08}, // 'p'
  {0x08,0x14,0x14,0x18,0x7C}, // 'q'
  {0x7C,0x08,0x04,0x04,0x08}, // 'r'
  {0x48,0x54,0x54,0x54,0x20}, // 's'
  {0x04,0x3F,0x44,0x40,0x20}, // 't'
  {0x3C,0x40,0x40,0x20,0x7C}, // 'u'
  {0x1C,0x20,0x40,0x20,0x1C}, // 'v'
  {0x3C,0x40,0x30,0x40,0x3C}, // 'w'
  {0x44,0x28,0x10,0x28,0x44}, // 'x'
  {0x0C,0x50,0x50,0x50,0x3C}, // 'y'
  {0x44,0x64,0x54,0x4C,0x44}, // 'z'
  {0x00,0x08,0x36,0x41,0x00}, // '{'
  {0x00,0x00,0x7F,0x00,0x00}, // '|'
  {0x00,0x41,0x36,0x08,0x00}, // '}'
  {0x08,0x04,0x08,0x10,0x08}  // '~' (ASCII 126)
};

// ===== SH1107 init =====
void oled_init(void) {
    _delay_ms(100);
    oled_cmd(0xAE); // Display Off
    oled_cmd(0xDC); oled_cmd(0x00); // Set display start line to 0
    oled_cmd(0x81); oled_cmd(0x2F); // Set contrast control
    oled_cmd(0x20); // Set Memory Addressing Mode -> Horizontal addressing mode
    oled_cmd(0xA0); // Set segment remap (0xA0 or 0xA1)
    oled_cmd(0xC0); // Set COM output scan direction (0xC0 or 0xC8)
    oled_cmd(0xA8); oled_cmd(0x7F); // Set multiplex ratio (1/128 duty)
    oled_cmd(0xD3); oled_cmd(0x00); // Set display offset (changed from 0x60 to 0x00 for display in the start)
    oled_cmd(0xD5); oled_cmd(0x51); // Set display clock divide ratio/oscillator frequency
    oled_cmd(0xD9); oled_cmd(0x22); // Set pre-charge period
    oled_cmd(0xDB); oled_cmd(0x35); // Set VCOMH deselect level
    oled_cmd(0xAD); oled_cmd(0x8A); // Set master configuration
    oled_cmd(0xA4); // Entire Display Off/On (0xA4: RAM content, 0xA5: All pixels On)
    oled_cmd(0xA6); // Set Normal/Inverse Display (0xA6: Normal, 0xA7: Inverse)
    oled_cmd(0xAF); // Display On
}

// ===== Cursor positioning =====
static void oled_set_cursor(uint8_t col, uint8_t page) {
    // Page address (0xB0 - 0xBF)
    oled_cmd(0xB0 + page);
    // Lower column address (0x00 - 0x0F)
    oled_cmd(0x00 + (col & 0x0F));
    // Higher column address (0x10 - 0x1F)
    oled_cmd(0x10 + (col >> 4));
}

// ===== Clear display =====
void oled_clear(void) {
    for (uint8_t page = 0; page < 16; page++) {
        oled_set_cursor(0, page);
        for (uint8_t col = 0; col < 128; col++) {
            oled_data(0x00); // Write black pixels
        }
    }
}

// ===== Print string (internal helper) =====
// Added 'inverted' parameter to control text inversion
static void oled_print_internal(const char *s, uint8_t inverted) {
    while (*s) {
        uint8_t c = *s++;
        // Handle characters outside the font table range
        if (c < 32 || c > 126) c = 32; // Use space character for unsupported chars

        // Print 5 columns of character data
        for (uint8_t j = 0; j < 5; j++) {
            if (inverted) {
                oled_data(~font5x7[c-32][j]); // Invert and send data
            } else {
                oled_data(font5x7[c-32][j]); // Send normal data
            }
        }
        // Print 1 column of space after character for separation
        if (inverted) {
            oled_data(0xFF); // Inverted space (white column)
        } else {
            oled_data(0x00); // Normal space (black column)
        }
    }
}

// ===== Public function to print string at specific row =====
// Now includes an 'inverted' parameter
void oled_print_at(const char *s, uint8_t row, uint8_t inverted) {
    if (row > 15) return; // Ensure row is within display bounds (0-15 for 128x128)
    uint8_t column_offset = 8; // Adjust this for starting column change, keeping it consistent with the example for SH1107's internal addressing.
    oled_set_cursor(column_offset, row);
    oled_print_internal(s, inverted); // Call the internal print function with inversion flag
}

